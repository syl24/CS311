#lang plai

;; NOTE: We expect not to grade roughly two of the eight questions,
;; but we're not saying which ones, and they're all good for practice!
;; :)

;; Running this will make it so that only the failed tests print out:
(print-only-errors)

;;;; PROBLEM #1 ;;;;
;;
;; Complete the function.  There's some messy math here,
;; but the real point is to look up help in the Racket
;; documentation! :)

;; fermat-primality-test : positive positive -> bool
;; Given an integer a >= 2 and an integer n > a, determine
;; whether the remainder when we divide a^(n-1) by n
;; is equal to 1. Note that a^(n-1) is a raised to the
;; power of n-1.
;;
;; It isn't important for our purposes to know this, but
;; the Fermat primality test is a step toward a good
;; "probabilistic primality test", trying to test whether
;; n is prime. As is, the test is "complete but not sound"
;; meaning that if it says false, it's correct, but if
;; it says true, it may be incorrect.
;;
;; Hint: look up the identifier "expt" in the helpdesk.
;; Then, look up (or just look around from there) for
;; "remainder".
(define (fermat-primality-test a n)
  (if (and (>= a 2) (> n a))
      (if (= 1 (remainder (expt a (- n 1)) n))
          true
          false)
      false
      ) 
   )


; Smallest case
(test (fermat-primality-test 2 3) true)

; A false case
(test (fermat-primality-test 2 4) false)

; A few extra true and false cases, including one that shows
; that this is not a sound primality test!
(test (fermat-primality-test 2 6) false)
(test (fermat-primality-test 3 7) true)
(test (fermat-primality-test 4 6) false)
(test (fermat-primality-test 2 341) true)

;;;; PROBLEM #2 ;;;;
;;
;; Complete the function.  
;; You'll certainly want to look up string functions to make this work.
;; You could also convert the strings to lists and work with them in that form!

;; match-length : string string -> natural

;; Compute the number of letters exactly matching at the start of the two strings
;; (before there's a difference).
;;
;; E.g., (match-length "wesselton" "weasel-town") evaluates to 2.
(define (match-length string1 string2)
  ; Feel free NOT to use the provided local variable definition here:
  (local [(define shorter-len (min (string-length string1)
                                   (string-length string2)))]
    (if (= shorter-len 0)
        0
        (length (take-common-prefix (string->list string1) (string->list string2))) )))

; Trivial cases.
(test (match-length "" "") 0)
(test (match-length "" "elsa") 0)
(test (match-length "elsa" "") 0)

; Simple one-character match/non-match.
(test (match-length "a" "a") 1)
(test (match-length "a" "b") 0)

; Matching prefixes.
(test (match-length "wesselton" "weasel-town") 2)

; One is a prefix of the other.
(test (match-length "weasel" "weasel-town") 6)
(test (match-length "weasel-town" "weasel") 6)

; Exactly matching longer strings.
(test (match-length "Sven" "Sven") 4)  ; they're both Sven?!

; Case matters
(test (match-length "a" "A") 0)
